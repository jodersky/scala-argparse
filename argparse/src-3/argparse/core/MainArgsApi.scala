package argparse.core

trait MainArgsApi { types: TypesApi with ParsersApi =>

  /** Find all methods annotated with `@argparse.main` declared in the container
    * `A`.
    *
    * ```
    * class Container() {
    *   @argparse.main()
    *   def command1() = ...
    *
    *  @argparse.main()
    *   def command2() = ...
    * }
    *
    * argparse.default.findMains[Container] = Seq(command1, command2)
    * ```
    */
  inline def findMains[A]: List[Entrypoint[A]] = ${
    EntrypointsMetadata.findMainsImpl[this.type, A]
  }

  /** Generate a main method for a single entry point.
    *
    * Once annotation macros become available in scala 3, and when `container`
    * is static, this method should become obsolete.
    */
  inline def main[A](container: => A, args: Array[String]): Unit = ${
    EntrypointsMetadata.mainImpl[this.type, A]('container, 'args)
  }

}

/** A wrapper around an application entrypoint.
  *
  * This is glue code that is typically generated by a macro. It represents an
  * application method that has been lifted into a lambda.
  *
  * @tparam A Type of the class containing the entrypoint.
  * @param name The name of the entrypoint. This can be used as the name of a
  * subcommand.
  * @param invoke Run the wrapped method on the given instance and arguments.
  */
case class Entrypoint[A](
  name: String,
  invoke: A => Iterable[String] => Unit
)
object EntrypointsMetadata {
  import scala.quoted.Quotes
  import scala.quoted.Expr
  import scala.quoted.Type
  import TextUtils.kebabify

  def findMainsImpl[Api <: TypesApi with ParsersApi: Type, A: Type](using qctx: Quotes): Expr[List[Entrypoint[A]]] = {
    val e = Expr.ofList(findAllMainsImpl[Api, A])
    //System.err.println(e.show)
    e
  }
  def findAllMainsImpl[Api <: TypesApi with ParsersApi: Type, A: Type](using qctx: Quotes): List[Expr[Entrypoint[A]]] = {
    import qctx.reflect._

    val container = TypeRepr.of[A].typeSymbol

    val mainMethods: List[Symbol] = container.declaredMethods.filter{ m =>
      // try {
        m.hasAnnotation(TypeRepr.of[argparse.main].typeSymbol)
      // } catch {
      //   case _: Exception =>
      //     // Hack Alert: if this macro is expanded as a method in the container
      //     // itself, then it will lead to a cyclic dependency. This case here
      //     // catches the cyclic dependency exception and simply ignores the
      //     // method.
      //     //
      //     // TODO: is there a better way to avoid the potential cyclic dependency
      //     // in the first place?
      //     false
      // }
    }

    val prefix: Expr[Api] = Ref(TypeRepr.of[Api].typeSymbol.companionModule).asExprOf[Api]

    for method <- mainMethods yield {

      val invoke = '{

        (instance: A) => (args: Iterable[String]) => {
          val parser = $prefix.ArgumentParser()
          val accessors: Seq[argparse.Argument[_]] = ${
            val defaults = getDefaultParamValues(using qctx)('instance, method)
            Expr.ofSeq(
              for param <- method.paramSymss.flatten yield
                paramAccessor(using qctx)(param, defaults, prefix, 'parser)
            )
          }
          parser.parseOrExit(args)
          val results = accessors.map(_.value)
          ${callFun(using qctx)('instance, method, 'results)}
          ()
        }
      }
      '{
        Entrypoint(
          ${Expr(kebabify(method.name))},
          $invoke
        )
      }
    }
  }

  // call a function with given arguments
  def callFun(using qctx: Quotes)(
    instance: Expr[_],
    method: qctx.reflect.Symbol,
    args: Expr[Seq[Any]]
  ): Expr[_] = {
    import qctx.reflect._
    val paramss = method.paramSymss


    if (paramss.isEmpty) {
      report.error("At least one parameter list must be declared.", method.pos.get)
      return '{???}
    }

    var idx = 0
    val accesses: List[List[Term]] = for (i <- paramss.indices.toList) yield {
      for (j <- paramss(i).indices.toList) yield {

        val paramTpt = paramss(i)(j).tree.asInstanceOf[ValDef].tpt
        val paramTpe = paramTpt.tpe
        val pt = paramTpe.asType.asInstanceOf[Type[Any]]

        val expr = paramTpe match {
          case AnnotatedType(tpe, annot) if annot.symbol.owner == defn.RepeatedAnnot =>
            report.error("Varargs are not yet supported in main methods. Use a Seq[_] instead.", paramTpt.pos)
            '{???}
          case _ =>
            '{$args(${Expr(idx)}).asInstanceOf[pt.Underlying]}
        }

        idx += 1
        expr.asTerm
      }
    }

    val fct = Select(instance.asTerm, method)
    val base = Apply(fct, accesses.head)
    val application: Apply = accesses.tail.foldLeft(base)((lhs, args) => Apply(lhs, args))
    val expr = application.asExpr
    expr
  }

  def getDefaultParamValues(using qctx: Quotes)(instance: Expr[_], method: qctx.reflect.Symbol): Map[qctx.reflect.Symbol, Expr[_]] = {
    import qctx.reflect._

    val pairs = for
      (param, idx) <- method.paramSymss.flatten.zipWithIndex
      if (param.flags.is(Flags.HasDefault))
    yield {
      val defaultName = s"${method.name}$$default$$${idx + 1}"
      val tree = Select(instance.asTerm, method.owner.memberMethod(defaultName).head)
      param -> tree.asExpr
    }
    pairs.toMap
  }

  def paramAccessor[Api <: TypesApi with ParsersApi: Type](using qctx: Quotes)(
    param: qctx.reflect.Symbol,
    defaults: Map[qctx.reflect.Symbol, Expr[Any]],
    prefix: Expr[Api],
    parser: Expr[_] // == prefix.ArgumentParser
  ): Expr[argparse.Argument[_]] = {
    import qctx.reflect._

    val annot: Expr[argparse.arg] = param.getAnnotation(TypeRepr.of[argparse.arg].typeSymbol) match {
      case Some(a) => a.asExprOf[argparse.arg]
      case None => '{argparse.arg()} // use default arg() values
    }

    val paramTpt = param.tree.asInstanceOf[ValDef].tpt
    val paramTpe = param.tree.asInstanceOf[ValDef].tpt.tpe
    def summonReader(tpe: TypeRepr): Expr[_] = {
      val readerTpe: Type[Any] =
        Applied(
          TypeSelect(
            prefix.asTerm,
            "Reader"
          ),
          List(paramTpt)
        ).tpe.asType.asInstanceOf[Type[Any]]
      Expr.summon(using readerTpe) match {
        case Some(r) => r
        case None =>
          report.error(s"no ${Type.show(using readerTpe)} available for parameter ${param.name}", param.pos.get)
          '{???}
      }
    }

    defaults.get(param) match {
      // repeated --named
      case Some(default) if paramTpe <:< TypeRepr.of[Seq[_]] =>
        val AppliedType(_, List(inner)) = paramTpe.dealias
        val tpe = inner.asType.asInstanceOf[Type[Any]]
        '{
          val p = $prefix
          $parser.asInstanceOf[p.ArgumentParser].repeatedParam[tpe.Underlying](
            name = ${Expr("--" + kebabify(param.name))},
            aliases = $annot.aliases,
            help = $annot.doc,
            flag = ${Expr(TypeRepr.of[tpe.Underlying] <:< TypeRepr.of[Boolean])}
          )(using ${summonReader(inner)}.asInstanceOf[p.Reader[tpe.Underlying]])
        }

      // --named
      case Some(default) =>
        val tpe = paramTpe.asType.asInstanceOf[Type[Any]]
        '{
          val p = $prefix
          $parser.asInstanceOf[p.ArgumentParser].singleParam[tpe.Underlying](
            name = ${Expr("--" + kebabify(param.name))},
            default = Some(() => $default.asInstanceOf[tpe.Underlying]),
            env = Option($annot.env),
            aliases = $annot.aliases,
            help = $annot.doc,
            flag = ${Expr(TypeRepr.of(using tpe) =:= TypeRepr.of[Boolean])},
            endOfNamed = false,
            interactiveCompleter = None,
            standaloneCompleter = None,
            argName = None
          )(using ${summonReader(paramTpe)}.asInstanceOf[p.Reader[tpe.Underlying]])
        }

      // repeated positional
      case None if paramTpe <:< TypeRepr.of[Seq[_]] =>
        val AppliedType(_, List(inner)) = paramTpe.dealias
        val tpe = inner.asType.asInstanceOf[Type[Any]]
        '{
          val p = $prefix
          $parser.asInstanceOf[p.ArgumentParser].repeatedParam[tpe.Underlying](
            name = ${Expr(kebabify(param.name))},
            aliases = $annot.aliases,
            help = $annot.doc,
            flag = false
          )(using ${summonReader(inner)}.asInstanceOf[p.Reader[tpe.Underlying]])
        }

      // positional
      case None =>
        val tpe = paramTpe.asType.asInstanceOf[Type[Any]]
        '{
          val p = $prefix
          $parser.asInstanceOf[p.ArgumentParser].singleParam[tpe.Underlying](
            ${Expr(kebabify(param.name))},
            default = None,
            env = Option($annot.env),
            aliases = $annot.aliases,
            help = $annot.doc,
            flag = false,
            endOfNamed = false,
            interactiveCompleter = None,
            standaloneCompleter = None,
            argName = None
          )(using ${summonReader(paramTpe)}.asInstanceOf[p.Reader[tpe.Underlying]])
        }
    }
  }

  def mainImpl[Api <: TypesApi with ParsersApi: Type, A: Type](using qctx: Quotes)(container: Expr[A], args: Expr[Array[String]]) = {
    import qctx.reflect._
    findAllMainsImpl[Api, A] match {
      case Nil =>
        report.error(s"No main method found in ${TypeRepr.of[A].show}. The container object must contain exactly one method annotated with @argparse.main")
        '{???}
      case head :: Nil =>
        '{
          $head.invoke($container)($args.toIterable)
        }
      case list =>
        report.error(s"Too many main methods found in ${TypeRepr.of[A].show}. The container object must contain exactly one method annotated with @argparse.main")
        '{???}
    }
  }
}
