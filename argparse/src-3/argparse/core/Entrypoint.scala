package argparse.core

/** A wrapper around an application entrypoint.
  *
  * This is glue code that is typically generated by a macro. It represents an
  * application method that has been lifted into a lambda, which takes an array
  * of command line arguments and calls the method.
  *
  * @param name The name of the entrypoint. This can be used as the name of a
  * subcommand.
  * @param invoke Run the wrapped method.
  */
case class Entrypoint(
  name: String,
  invoke: (Iterable[String], Map[String, String]) => Unit
)

object Entrypoint:
  import scala.quoted.Quotes
  import scala.quoted.Expr
  import scala.quoted.Type

  // call a function with given arguments
  def callFun(using qctx: Quotes)(
    instance: qctx.reflect.Term,
    method: qctx.reflect.Symbol,
    args: Expr[Seq[Any]]
  ): Expr[_] =
    import qctx.reflect._
    val paramss = method.paramSymss

    if paramss.isEmpty then
      report.error("At least one parameter list must be declared.", method.pos.get)
      return '{???}

    var idx = 0
    val accesses: List[List[Term]] = for i <- paramss.indices.toList yield
      for j <- paramss(i).indices.toList yield

        val paramTpt = paramss(i)(j).tree.asInstanceOf[ValDef].tpt
        val paramTpe = paramTpt.tpe
        val pt = paramTpe.asType.asInstanceOf[Type[Any]]

        val expr = paramTpe match
          case AnnotatedType(tpe, annot) if annot.symbol.owner == defn.RepeatedAnnot =>
            report.error("Varargs are not yet supported in main methods. Use a Seq[_] instead.", paramTpt.pos)
            '{???}
          case _ =>
            '{$args(${Expr(idx)}).asInstanceOf[pt.Underlying]}

        idx += 1
        expr.asTerm

    val fct = Select(instance, method)
    val base = Apply(fct, accesses.head)
    val application: Apply = accesses.tail.foldLeft(base)((lhs, args) => Apply(lhs, args))
    val expr = application.asExpr
    expr
  end callFun

  def getDefaultParamValues(using qctx: Quotes)(instance: qctx.reflect.Term, method: qctx.reflect.Symbol): Map[qctx.reflect.Symbol, qctx.reflect.Term] = {
    import qctx.reflect._

    val pairs = for
      (param, idx) <- method.paramSymss.flatten.zipWithIndex
      if (param.flags.is(Flags.HasDefault))
    yield {
      val defaultName = s"${method.name}$$default$$${idx + 1}"
      val tree = Select(instance, method.owner.memberMethod(defaultName).head)
      param -> tree
    }
    pairs.toMap
  }

  def mainImpl[Api <: MainArgsApi: Type, Container: Type](using qctx: Quotes)
      (api: Expr[Api], container: Expr[Container], args: Expr[Iterable[String]], env: Expr[Map[String, String]]): Expr[Unit] =
    import qctx.reflect._

    // Note: for prettier error messages, instead of forwarding `api`, we get it
    // from its type.
    // This leads to error messages which look like
    //
    // > no AnnotationTest.parsing.Reader[wrapper.Foo] available for parameter foo
    //
    // instead of
    //
    // > no MainArgsApi_this.ParamBuilder[wrapper.Foo] available for parameter foo
    val prefix: Expr[Api] = Ref(TypeRepr.of[Api].typeSymbol.companionModule).asExprOf[Api]
    findAllMains[Api, Container](prefix, container) match {
      case Nil =>
        report.error(s"No main method found in ${TypeRepr.of[Container].show}. The container object must contain exactly one method annotated with @argparse.main")
        '{???}
      case head :: Nil =>
        '{
          $head.invoke($args, $env)
        }
      case list =>
        report.error(s"Too many main methods found in ${TypeRepr.of[Container].show}. The container object must contain exactly one method annotated with @argparse.main")
        '{???}
    }

  def findAllMains[Api <: MainArgsApi: Type, Container: Type](using qctx: Quotes)
      (api: Expr[Api], container: Expr[Container]): List[Expr[Entrypoint]] =
    import qctx.reflect._

    // val container = TypeRepr.of[A].typeSymbol
    // val prefix: Expr[Api] = Ref(TypeRepr.of[Api].typeSymbol.companionModule).asExprOf[Api]

    val mainType = TypeSelect(api.asTerm, "main").tpe.typeSymbol

    for
      method <- TypeRepr.of[Container].typeSymbol.declaredMethods
      if method.hasAnnotation(mainType)
    yield
      makeEntrypoint[Api, Container](api, container.asTerm, method)

  def makeEntrypoint[Api <: MainArgsApi: Type, Container: Type](using qctx: Quotes)
      (api: Expr[Api], container: qctx.reflect.Term, method: qctx.reflect.Symbol): Expr[Entrypoint] =
    import qctx.reflect._

    val doc = method.docstring match
      case Some(s) => DocComment.extract(s)
      case None => DocComment(Seq(), Map())

    val defaultParamValues = getDefaultParamValues(container, method)

    '{
      val invoke = (args: Iterable[String], env: Map[String, String]) =>
        val parser = $api.ArgumentParser(description = ${Expr(doc.paragraphs.mkString("\n"))})
        val accessors: Seq[() => _] = ${
          Expr.ofSeq(
            for param <- method.paramSymss.flatten yield
              paramAccessor[Api](using qctx)(api, doc.params.toMap, defaultParamValues, param, 'parser)
          )
        }
        parser.parseOrExit(args)
        val paramValues = accessors.map(_())
        ${callFun(using qctx)(container, method, 'paramValues)}
        ()

      Entrypoint(
        $api.commandName(${Expr(method.name)}),
        invoke
      )
    }

  def paramAccessor[Api <: MainArgsApi: Type](using qctx: Quotes)(
    api: Expr[Api],
    docs: Map[String, String],
    defaults: Map[qctx.reflect.Symbol, qctx.reflect.Term],
    param: qctx.reflect.Symbol,
    argumentParser: Expr[_]
  ): Expr[() => Any] = {
    import qctx.reflect._

    val annot: Expr[argparse.arg] = param.getAnnotation(TypeRepr.of[argparse.arg].typeSymbol) match {
      case Some(a) => a.asExprOf[argparse.arg]
      case None => '{argparse.arg()} // use default arg() values
    }

    val paramTpt = param.tree.asInstanceOf[ValDef].tpt
    val paramTpe = param.tree.asInstanceOf[ValDef].tpt.tpe.asType
    val makerTpe = Applied(
      TypeSelect(
        api.asTerm,
        "ParamBuilder"
      ),
      List(paramTpt)
    ).tpe.asType

    val makerExpr: Expr[Any] = makerTpe match
      case '[t] =>
        Expr.summon[t] match
          case Some(r) => r
          case None =>
            report.error(
              s"No ${api.show}.Reader[${Type.show(using paramTpe)}] available for parameter ${param.name}. " +
                s"You can find instructions on how to define a new Reader here: https://jodersky.github.io/scala-argparse/index.html#adding-support-for-a-new-type-of-parameter",
              param.pos.get
            )
            '{???}

    paramTpe match
      case '[t] =>
        val defaultValue: Expr[Option[() => t]] = defaults.get(param) match
          case None => '{None}
          case Some(value) => '{Some(() => ${value.asExprOf[t]})}
        '{
          val p = $api
          val maker = $makerExpr.asInstanceOf[p.ParamBuilder[t]]
          maker.makeParams(
            name = p.paramName(${Expr(param.name)}),
            description = ${Expr(docs.getOrElse(param.name, ""))},
            default = $defaultValue,
            annot = $annot,
            argparser = $argumentParser.asInstanceOf[p.ArgumentParser]
          )
        }
  }
